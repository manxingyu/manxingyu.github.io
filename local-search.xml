<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>opencv库函数</title>
    <link href="/2022/08/15/page/"/>
    <url>/2022/08/15/page/</url>
    
    <content type="html"><![CDATA[<h1 id="图像显示、处理："><a href="#图像显示、处理：" class="headerlink" title="图像显示、处理："></a>图像显示、处理：</h1><h2 id="cv2-imread"><a href="#cv2-imread" class="headerlink" title="cv2.imread"></a>cv2.imread</h2><p>img &#x3D;cv2.imread(“address”,flags)</p><p>flags：标志位，{cv2.IMREAD_COLOR，cv2.IMREAD_GRAYSCALE，cv2.IMREAD_UNCHANGED}</p><p>cv2.IMREAD_COLOR：默认参数，读入一副彩色图片，忽略alpha通道，可用1作为实参替代</p><p>cv2.IMREAD_GRAYSCALE：读入灰度图片，可用0作为实参替代</p><p>cv2.IMREAD_UNCHANGED：顾名思义，读入完整图片，包括alpha通道，可用-1作为实参替代</p><p>PS：alpha通道，又称A通道，是一个8位的灰度通道，该通道用256级灰度来记录图像中的透明度复信息，定义透明、不透明和半透明区域，其中黑表示全透明，白表示不透明，灰表示半透明</p><h2 id="cv2-resize"><a href="#cv2-resize" class="headerlink" title="cv2.resize"></a>cv2.resize</h2><p>cv2.resize (图像,dsize&#x3D;None,fx&#x3D;2,fy&#x3D;2,interpolation)</p><p> cv2.resize（）函数中，主要用到的形参包括</p><p>输入Mat数据，</p><p>dsize：代表期望的输出图像大小尺寸</p><p>fx：代表水平方向上（图像宽度）的缩放系数，</p><p>fy：代表竖直方向上（图像高度）的缩放系数，另外，如果dsize被设置为0（None），则按fx与fy与原始图像大小相乘得到输出图像尺寸大小。</p><p>interpolation：插值方式，默认选择线性插值，越复杂的插值方式带来的改变和差异越大。</p><h2 id="cv2-imshow"><a href="#cv2-imshow" class="headerlink" title="cv2.imshow"></a>cv2.imshow</h2><p>原型：imshow(winname,mat)<br> 作用：创建一个图像窗口<br> 参数：winname，窗口名称。mat，图像矩阵。</p><h2 id="cv2-waitKey"><a href="#cv2-waitKey" class="headerlink" title="cv2.waitKey"></a>cv2.waitKey</h2><p>原型：waitKey(delay&#x3D;None) 为0 时则是等待按键的意思<br> 作用；接受一个按键事件并返回按键的ASCII码。<br> 参数：delay为按下后返回的延迟时间。</p><h2 id="cv2-destroyWindow"><a href="#cv2-destroyWindow" class="headerlink" title="cv2.destroyWindow"></a>cv2.destroyWindow</h2><p>原型： destroyWindow(winname)<br> 作用：关闭一个由imshow产生的图像窗口<br> 参数：winname，关闭的窗口名字</p><h2 id="cv2-cvtColor"><a href="#cv2-cvtColor" class="headerlink" title="cv2.cvtColor"></a>cv2.cvtColor</h2><p>原型：cvtColor(src,code,dst&#x3D;None,dstCn&#x3D;None)<br> 作用：将一幅图像从一个色彩空间转换到另一个色彩空间<br> 参数：code，转换的色彩空间</p><h2 id="cv2-threshold"><a href="#cv2-threshold" class="headerlink" title="cv2.threshold"></a>cv2.threshold</h2><p>原型：threshold(src,thresh,maxval,type,dst&#x3D;None)<br> 作用：将图像的每个像素点进行二值化<br> 参数：thresh，阈值值。maxval，二值化的最大取值。type，二值化类型，一般设为0</p><h2 id="cv2-selectROI"><a href="#cv2-selectROI" class="headerlink" title="cv2.selectROI"></a>cv2.selectROI</h2><p>rect &#x3D; cv2.selectROI(“image”, img, showCrosshair, fromCenter)</p><p>“image” : winName 窗口名称</p><p>img : 目标想要裁剪的图像</p><p>showCrosshair : 是否显示网格</p><p>True 显示网格</p><p>False 只有矩形</p><p>fromCenter:</p><p>True 第一次选中的点为矩形的中心.</p><p>False 第一次选中的点为矩形的左上角.</p><p>返回的是一个tuple值, 代表矩形区域. 分别代表矩形左上角坐标 (x, y) 与矩形宽度<code>w</code>跟高度<code>h</code></p><p>(x, y, w, h) &#x3D; rect</p><p>用法：</p><p>rect&#x3D;cv2.selectROI(“22”,img,False)<br> (x, y, w, h) &#x3D; rect<br> im &#x3D; img[y : y+h, x:x+w]</p><h2 id="cv2-Shape"><a href="#cv2-Shape" class="headerlink" title="cv2. Shape"></a>cv2. Shape</h2><p>返回值：</p><p>shape[0] &#x3D;图像的高<br> shape[1] &#x3D;图像的宽<br> shape[2] &#x3D; 图像的图像<a href="https://so.csdn.net/so/search?q=%E9%80%9A%E9%81%93&spm=1001.2101.3001.7020">通道</a>数量</p><h2 id="cv2-split（）"><a href="#cv2-split（）" class="headerlink" title="cv2.split（）"></a>cv2.split（）</h2><p>通道拆分</p><p>返回值：</p><p>b,g,r&#x3D; cv2.split（图像）</p><p>cv2.merge（[b, g, r]）</p><p>cv2.merge(mv[, dst]) -&gt; retval # BGR 通道合并</p><p>参数说明：</p><p>mv：要合并的单通道</p><p>dst：通道合并的图像，nparray 多维数组</p><p>Numpy库加法的运算方法为：</p><p>目标图像 &#x3D; 图像1 + 图像2，运算结果进行取模运算。有以下两种情况：</p><p>（1）当像素值 &lt;&#x3D; 255时，结果为“图像1+图像2”，例如：120+48&#x3D;168</p><p>（2）当像素值 &gt; 255时，结果为对255取模的结果，例如：(255+64) % 255&#x3D;64</p><h2 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h2><p>OpenCV库实现图像加法运算，方法如下：</p><p>目标图像 &#x3D; cv2.add(图像1, 图像2)  。 此时结果是饱和运算，有以下两种情况：</p><p>（1）当像素值 &lt;&#x3D; 255时，结果为“图像1+图像2”，例如：120+48&#x3D;168</p><p>（2）当像素值 &gt; 255时，结果为255，例如：(255+64) &#x3D; 255  <strong>注意与<strong><strong>numpy</strong></strong>加法运算的区别！！！</strong></p><h2 id="addWeighted"><a href="#addWeighted" class="headerlink" title="addWeighted()"></a>addWeighted()</h2><p>图像融合：目标图像 &#x3D; 图像1 系数1 + 图像2  系数2 + 亮度调节量</p><p>dst &#x3D; cv2.addWeighter(scr1, alpha, src2, beta, gamma)</p><p>dst &#x3D; src1 alpha + src2  beta + gamma</p><p>其中，参数gamma不能省略</p><h2 id="cv2-copyMakeBorder"><a href="#cv2-copyMakeBorder" class="headerlink" title="cv2.copyMakeBorder()"></a>cv2.copyMakeBorder()</h2><p>为图像扩边（填充）<br> 想为图像周围建一个边可以使用cv2.copyMakeBorder()函数。这经常在卷积运算或0填充时被用到。</p><h2 id="cv2-copyMakeBorder-src-top-bottom-left-right-borderType-value"><a href="#cv2-copyMakeBorder-src-top-bottom-left-right-borderType-value" class="headerlink" title="cv2.copyMakeBorder(src,top,bottom,left,right,borderType,value)"></a>cv2.copyMakeBorder(src,top,bottom,left,right,borderType,value)</h2><p>具体参数如下：<br> src输入图像<br> top,bottom,left,right对应边界的像素数目<br> borderType要添加哪种类型的边界：<br> cv2.BORDER_CONSTANT添加有颜色的常数值边界，还需要下一个参数（value）<br> cv2.BORDER_REFLIECT边界元素的镜像。例如：fedcba | abcdefgh | hgfedcb<br> cv2.BORDER_101或者cv2.BORDER_DEFAULT跟上面一样，但稍作改动，例如：gfedcb | abcdefgh | gfedcba<br> cv2.BORDER_REPLICATE复后一个元素。例如: aaaaaa| abcdefgh|hhhhhhh<br> cv2.BORDER_WRAP 不知怎么了, 就像样: cdefgh| abcdefgh|abcdefg<br> value:边界颜色</p><h2 id="cv2-inRange（）"><a href="#cv2-inRange（）" class="headerlink" title="cv2.inRange（）"></a>cv2.inRange（）</h2><p>mask &#x3D; cv2.inRange(hsv, lower, upper) </p><p>函数很简单，参数有三个</p><p>第一个参数：hsv指的是原图</p><p>第二个参数：lower_指的是图像中低于这个lower的值，图像值变为0</p><p>第三个参数：upper指的是图像中高于这个upper的值，图像值变为0</p><p>而在lower～upper之间的值变成255</p><p>可以用阈值的范围来选择颜色</p><p><img src="/img/page,hsv.jpg" alt="img"></p><h2 id="cv2-bitwise-and-src1src2-mask-x3D-X"><a href="#cv2-bitwise-and-src1src2-mask-x3D-X" class="headerlink" title="cv2.bitwise_and(src1src2,mask&#x3D;X)"></a>cv2.bitwise_and(src1src2,mask&#x3D;X)</h2><p> src1表示第一个array或scalar类型的输入值。</p><p> src2表示第二个array或scalar类型的输入值。</p><p>X表示可选操作掩码，8位单通道array，选择图像。</p><p>cv2.bitwise_and()是对二进制数据进行“与”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“与”操作，1&amp;1&#x3D;1，1&amp;0&#x3D;0，0&amp;1&#x3D;0，0&amp;0&#x3D;0</p><h2 id="空间域滤波"><a href="#空间域滤波" class="headerlink" title="空间域滤波"></a>空间域滤波</h2><h2 id="cv2-blur-原始图像-核大小"><a href="#cv2-blur-原始图像-核大小" class="headerlink" title="cv2.blur(原始图像,核大小)"></a>cv2.blur(原始图像,核大小)</h2><p>均值滤波</p><p>指任意一点的像素值，都是周围 NxM个像素值的均值</p><p>注：</p><p>1）随着核大小逐渐变大，会让图像变得更加模糊；</p><p>2）如果设置为核大小为（1，1），则结果就是原始图像。</p><h2 id="cv2-medianBlur-src-ksize"><a href="#cv2-medianBlur-src-ksize" class="headerlink" title="cv2.medianBlur(src, ksize)"></a><strong>cv2.medianBlur(src, ksize)</strong></h2><p>这里的核大小ksize必须是奇数</p><p>将该点周围的像素点包括本身，按次序排列，取中位数作为点的像素值</p><p><strong>注：</strong></p><p>1）随着核大小逐渐变大，会让图像变得更加模糊；</p><p>2）核必须是大于1的<strong>奇数</strong>，如3、5、7等；</p><p>3）在代码 <strong>dst &#x3D; cv2.medianBlur(src, ksize)</strong> 中 填写核大小时，只需填写一个数即可，如3、5、7等，对比均值滤波函数用法。</p><h2 id="cv2-GaussianBlur-src-ksize-sigmaX"><a href="#cv2-GaussianBlur-src-ksize-sigmaX" class="headerlink" title="cv2.GaussianBlur(src, ksize, sigmaX)"></a><strong>cv2.GaussianBlur(src, ksize, sigmaX)</strong></h2><p>dst &#x3D; cv2.GaussianBlur(src, ksize, sigmaX, sigmaY, borderType) </p><p>——src输入图像。</p><p>——dst输出图像的大小和类型与src相同。</p><p>——ksize高斯内核大小。 ksize.width和ksize.height可以不同，但它们都必须为正数和奇数，也可以为零，然后根据sigmaX和sigmaY计算得出。</p><p>——sigmaX X方向上的高斯核标准偏差。</p><p>——sigmaY Y方向上的高斯核标准差；如果sigmaY为零，则将其设置为等于sigmaX；如果两个sigmas为零，则分别从ksize.width和ksize.height计算得出；为了完全控制结果，而不管将来可能对所有这些语义进行的修改，建议指定所有ksize，sigmaX和sigmaY。</p><h2 id="形态学处理"><a href="#形态学处理" class="headerlink" title="形态学处理"></a>形态学处理</h2><p><strong>腐蚀</strong>：<strong>cv2.<strong><strong>erode</strong></strong>(src, kernel, iterations)   #iterations****表示腐蚀几次</strong></p><p><strong>膨胀：****cv2.<strong><strong>dilate</strong></strong>(src, kernel, iterations)</strong></p><p><strong>开运算：****cv2.<strong><strong>morphologyEx</strong></strong>(src, cv2.<strong><strong>MORPH_OPEN</strong></strong>, kernel)</strong></p><p>*<em>闭运算：</em>***cv2.****morphologyEx(**<strong>src, cv2.<strong><strong>MORPH_CLOSE</strong></strong>, kernel)</strong></p><p># 设置卷积核<br> kernel &#x3D; np.ones((3, 3), np.uint8)<br> ‘’’形态学6种操作’’’<br> # 腐蚀<br> fushi &#x3D; cv2.erode(src, kernel)<br> # 膨胀<br> pengzhang &#x3D; cv2.dilate(src, kernel)<br> # 开运算<br> kai &#x3D; cv2.morphologyEx(src, cv2.MORPH_OPEN, kernel)<br> # 闭运算<br> bi &#x3D; cv2.morphologyEx(src, cv2.MORPH_CLOSE, kernel)<br> # 顶帽运算<br> tophat &#x3D; cv2.morphologyEx(src, cv2.MORPH_TOPHAT, kernel)<br> # 黑帽运算<br> blackhat &#x3D; cv2.morphologyEx(src, cv2.MORPH_BLACKHAT, kernel)</p><p><a href="https://docs.opencv.org/4.x/d9/d61/tutorial_py_morphological_ops.html">OpenCV：形态学转化</a></p><p><img src="/img/page,1.jpg" alt="img"></p><h2 id="sobel算子"><a href="#sobel算子" class="headerlink" title="sobel算子"></a>sobel算子</h2><p># ddepth：cv2.CV_， 结果图像的位深</p><p># dx：对 x 方向求偏导</p><p># dy：对 y 方向求偏导</p><p># ksize：卷积核大小</p><p>cv2.Sobel(src, ddepth, dx:bool, dy:bool[, dst[, ksize:int[, scale[, delta[, borderType]]]]]) -&gt; dst</p><p>cv2.convertScaleAbs(src[, dst[, alpha[, beta]]]) -&gt; dst# src中的数据取绝对值</p><p>Sobel计算，会导致像素值为负，因此输出图像的位深ddepth应当使用「有符号类型」，例如cv2.CV_16S、cv2.CV_32F等</p><p>颜色通道数值不存在负数，所以还需要对计算结果取绝对值convertScaleAbs</p><p>对于横向、竖向的边界提取要分两次进行，一起提取效果很差</p><h2 id="Scharr算子（sobel算子改进版）"><a href="#Scharr算子（sobel算子改进版）" class="headerlink" title="Scharr算子（sobel算子改进版）"></a>Scharr算子（sobel算子改进版）</h2><p>cv2.Scharr(src, ddepth, dx, dy[, dst[, scale[, delta[, borderType]]]]) -&gt; dst</p><p>相比sobel算子卷积核ksize大小固定为<code>3x3</code></p><p>src：原始图像</p><p>ddepth：处理结果图像深度</p><p>dx：x轴方向</p><p>dy：y轴方向</p><h2 id="Laplacian算子"><a href="#Laplacian算子" class="headerlink" title="Laplacian算子"></a>Laplacian算子</h2><p><strong>dst &#x3D; cv2.Laplacian(src, ddepth)</strong></p><p> 注意：通常情况下，可以将图像深度ddepth的值设置为-1，让处理结果与原始图像保持一致</p><h2 id="cv2-Canny（）"><a href="#cv2-Canny（）" class="headerlink" title="cv2.Canny（）"></a>cv2.Canny（）</h2><p><strong>edges &#x3D;  cv2.Canny(image, threshold1, threshold2)</strong></p><p>image： 原始图像</p><p>threshold1： 阈值1 minVal</p><p>threshold2： 阈值2 maxVal</p><p> threshold值越小，细节越丰富</p><h2 id="cv2-pyrDown-img"><a href="#cv2-pyrDown-img" class="headerlink" title="cv2. pyrDown(img)"></a>cv2. pyrDown(img)</h2><p>将img图像缩小2倍</p><h2 id="cv2-pyrUp-img"><a href="#cv2-pyrUp-img" class="headerlink" title="cv2. pyrUp(img)"></a>cv2. pyrUp(img)</h2><p>将img图像放大两倍 </p><h2 id="cv2-findContours-image-mode-method"><a href="#cv2-findContours-image-mode-method" class="headerlink" title="cv2.findContours(image, mode, method)"></a>cv2.findContours(image, mode, method)</h2><p>mode: 轮廓检索模式</p><p>RETR_EXTERNAL:只检索最外面的轮廓；</p><p>RETR_LIST:检索所有的轮廓，并将其保存到一条链表当中；</p><p>RETR_CCOMP:检索所有的轮廓，并将他们组织为两层：顶层是各部分的外部边界，第二层是空洞的边界：</p><p><strong>RETR_TREE</strong>: 检索所有的轮廓，并重构嵌套轮廓的整个层次； <strong>最常用。</strong></p><p>method: 重新绘制轮廓的算法</p><p>CHAIN_APPROX_NONE:以Freeman链码的方式输出轮廓，轮廓信息完整保留</p><p>CHAIN_APPROX_SIMPLE:压缩水平的、垂直的和斜的部分，只保留顶点</p><p><strong>函数返回值：contours, hierarchy</strong></p><p>contours：从图像中查找出来的轮廓数组</p><p>hierarchy：轮廓层级</p><h2 id="cv2-drawContours（）"><a href="#cv2-drawContours（）" class="headerlink" title="cv2.drawContours（）"></a>cv2.drawContours（）</h2><p>canvas：轮廓要绘制在哪张背景图上，直接覆盖原图</p><p>contours：findContours 找到的轮廓信息</p><p>contourIdx：轮廓数组contours的索引值，-1 为全部</p><p>color：轮廓颜色</p><p>thickness：轮廓厚度</p><p>cv2.drawContours(canva:image, contours, contourIdx, color， thickness) -&gt; image</p><h1 id="时间的测量和计时："><a href="#时间的测量和计时：" class="headerlink" title="时间的测量和计时："></a>时间的测量和计时：</h1><p><a href="https://docs.opencv.org/4.0.0/db/de0/group__core__utils.html#gae73f58000611a1af25dd36d496bf4487"><strong>cv.getTickCount</strong></a>函数返回参考事件（如机器开启时刻）到调用此函数的时钟周期数。因此，如果在函数执行之前和之后调用它，则会获得用于执行函数的时钟周期数。</p><p><a href="https://docs.opencv.org/4.0.0/db/de0/group__core__utils.html#ga705441a9ef01f47acdc55d87fbe5090c"><strong>cv.getTickFrequency</strong></a>函数返回时钟周期的频率，或每秒钟的时钟周期数</p><p><code>e1 </code>&#x3D;<code> cv</code>.<code>getTickCount</code>()&#96;&#96;</p><p>#你的执行的代码&#96;&#96;</p><p><code>e2 </code>&#x3D;<code> cv</code>.<code>getTickCount</code>()&#96;&#96;</p><p><code>time </code>&#x3D;<code> </code>(<code>e2 </code>-<code> e1</code>)&#x2F;<code>cv</code>.<code>getTickFrequency</code>()</p>]]></content>
    
    
    
    <tags>
      
      <tag>opencv</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typora使用教程</title>
    <link href="/2022/08/14/test/"/>
    <url>/2022/08/14/test/</url>
    
    <content type="html"><![CDATA[<h1 id="typora使用教程—如何优美的书写markdowm文件"><a href="#typora使用教程—如何优美的书写markdowm文件" class="headerlink" title="typora使用教程—如何优美的书写markdowm文件"></a>typora使用教程—如何优美的书写markdowm文件</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><blockquote><h4 id="Markdown是什么？"><a href="#Markdown是什么？" class="headerlink" title="Markdown是什么？"></a>Markdown<em>是什么</em>？</h4><h4 id="谁创造了它？"><a href="#谁创造了它？" class="headerlink" title="谁创造了它？"></a><em>谁</em>创造了它？</h4><h4 id="为什么要使用它？"><a href="#为什么要使用它？" class="headerlink" title="为什么要使用它？"></a><em>为什么</em>要使用它？</h4><h4 id="怎么使用？"><a href="#怎么使用？" class="headerlink" title="怎么使用？"></a><em>怎么</em>使用？</h4></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-Markdown是什么？"><a href="#1-Markdown是什么？" class="headerlink" title="1. Markdown是什么？"></a>1. Markdown<em>是什么</em>？</h3><p><strong>Markdown</strong>是一种轻量级<strong>标记语言</strong>，它以纯文本形式(<em>易读、易写、易更改</em>)编写文档，并最终以HTML格式发布。<br><strong>Markdown</strong>也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。    </p><h3 id="2-谁创造了它？"><a href="#2-谁创造了它？" class="headerlink" title="2. 谁创造了它？"></a>2. <em>谁</em>创造了它？</h3><p>它由<a href="http://www.aaronsw.com/"><strong>Aaron Swartz</strong></a>和<strong>John Gruber</strong>共同设计，<strong>Aaron Swartz</strong>就是那位于（<em>2013年1月11日</em>）自杀,有着<strong>开挂</strong>一般人生经历的程序员。维基百科对他的<a href="http://zh.wikipedia.org/wiki/%E4%BA%9A%E4%BC%A6%C2%B7%E6%96%AF%E6%B2%83%E8%8C%A8">介绍</a>是：<strong>软件工程师、作家、政治组织者、互联网活动家、维基百科人</strong>。    </p><p>他有着足以让你跪拜的人生经历：    </p><ul><li><strong>14岁</strong>参与RSS 1.0规格标准的制订。     </li><li><strong>2004</strong>年入读<strong>斯坦福</strong>，之后退学。   </li><li><strong>2005</strong>年创建<a href="http://infogami.org/">Infogami</a>，之后与<a href="http://www.reddit.com/">Reddit</a>合并成为其合伙人。   </li><li><strong>2010</strong>年创立求进会（Demand Progress），积极参与禁止网络盗版法案（SOPA）活动，最终该提案被撤回。   </li><li><strong>2011</strong>年7月19日，因被控从MIT和JSTOR下载480万篇学术论文并以免费形式上传于网络被捕。     </li><li><strong>2013</strong>年1月自杀身亡。</li></ul><p><img src="https://github.com/younghz/Markdown/raw/master/resource/Aaron_Swartz.jpg" alt="Aaron Swartz"></p><p>天才都有早逝的归途。</p><h3 id="3-为什么要使用它？"><a href="#3-为什么要使用它？" class="headerlink" title="3. 为什么要使用它？"></a>3. <em>为什么</em>要使用它？</h3><ul><li>它是易读（看起来舒服）、易写（语法简单）、易更改<strong>纯文本</strong>。处处体现着<strong>极简主义</strong>的影子。</li><li>兼容HTML，可以转换为HTML格式发布。</li><li>跨平台使用。</li><li>越来越多的网站支持Markdown。</li><li>更方便清晰地组织你的电子邮件。（Markdown-here, Airmail）</li><li>摆脱Word（我不是认真的）。</li></ul><h3 id="4-怎么使用？"><a href="#4-怎么使用？" class="headerlink" title="4. 怎么使用？"></a>4. <em>怎么</em>使用？</h3><p>如果不算<strong>扩展</strong>，Markdown的语法绝对<strong>简单</strong>到让你爱不释手。</p><p>Markdown语法主要分为如下几大部分：<br><strong>标题</strong>，<strong>段落</strong>，<strong>区块引用</strong>，<strong>代码区块</strong>，<strong>强调</strong>，<strong>列表</strong>，<strong>分割线</strong>，<strong>链接</strong>，<strong>图片</strong>，**反斜杠 <code>\</code><strong>，</strong>符号’&#96;’**。</p><h4 id="4-1-标题"><a href="#4-1-标题" class="headerlink" title="4.1 标题"></a>4.1 标题</h4><p>一、使用<code>#</code>，可表示1-6级标题。</p><blockquote><p># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题    </p></blockquote><h4 id="4-2-段落"><a href="#4-2-段落" class="headerlink" title="4.2 段落"></a>4.2 段落</h4><p>段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用<strong>两个以上</strong>空格加上回车（引用中换行省略回车）。</p><h4 id="4-3-区块引用"><a href="#4-3-区块引用" class="headerlink" title="4.3 区块引用"></a>4.3 区块引用</h4><p>在段落的每行或者只在第一行使用符号<code>&gt;</code>,还可使用多个嵌套引用，如：</p><blockquote><p>&gt; 区块引用<br>&gt;&gt; 嵌套引用  </p></blockquote><p>效果：</p><blockquote><p>区块引用  </p><blockquote><p>嵌套引用</p></blockquote></blockquote><h4 id="4-4-代码区块"><a href="#4-4-代码区块" class="headerlink" title="4.4 代码区块"></a>4.4 代码区块</h4><p>使用栅栏式代码块很简单：输入&#96;&#96;&#96;之后输入一个可选的语言标识符，然后按return键后输入代码，我们将通过语法高亮显示它：。如    </p><p>普通段落：</p><p>void main()<br>{<br>    printf(“Hello, Markdown.”);<br>}    </p><p>代码区块：</p><pre><code class="hljs">void main()&#123;    printf(&quot;Hello, Markdown.&quot;);&#125;</code></pre><p><strong>注意</strong>:需要和普通段落之间存在空行。</p><h4 id="4-5-强调"><a href="#4-5-强调" class="headerlink" title="4.5 强调"></a>4.5 强调</h4><p>在强调内容两侧分别加上<code>*</code>或者<code>_</code>，如：</p><blockquote><p>*斜体*，_斜体_<br>**粗体**，__粗体__</p></blockquote><p>效果：</p><blockquote><p><em>斜体</em>，<em>斜体</em><br><strong>粗体</strong>，<strong>粗体</strong></p></blockquote><h4 id="4-6-列表"><a href="#4-6-列表" class="headerlink" title="4.6 列表"></a>4.6 列表</h4><p>使用<code>·</code>、<code>+</code>、或<code>-</code>标记无序列表，如：</p><blockquote><p>-（+*） 第一项<br>-（+*） 第二项<br>- （+*）第三项</p></blockquote><p><strong>注意</strong>：标记后面最少有一个_空格_或_制表符_。若不在引用区块中，必须和前方段落之间存在空行。</p><p>效果：</p><blockquote><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><p>有序列表的标记方式是将上述的符号换成数字,并辅以<code>.</code>，如：</p><blockquote><p>1 . 第一项<br>2 . 第二项<br>3 . 第三项    </p></blockquote><p>效果：</p><blockquote><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol></blockquote><h4 id="4-7-分割线"><a href="#4-7-分割线" class="headerlink" title="4.7 分割线"></a>4.7 分割线</h4><p>输入 <code>***</code> 或 <code>---</code> 在空行上按 <code>return</code> 键将绘制一条水平线。</p><hr><h4 id="4-8-链接"><a href="#4-8-链接" class="headerlink" title="4.8 链接"></a>4.8 链接</h4><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p>参考样式链接使用第二组方括号，在其中放置您选择的标签以标识链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">This is [an example][<span class="hljs-built_in">id</span>] reference-style <span class="hljs-built_in">link</span>.<br><br>然后，在文档中的任何位置，您可以单独定义链接标签，如下所示：<br><br>[<span class="hljs-built_in">id</span>]: http://example.com/  <span class="hljs-string">&quot;Optional Title Here&quot;</span><br></code></pre></td></tr></table></figure><p>在typora中，它们将呈现为：</p><p>This is <a href="http://example.com/">an example</a> reference-style link.</p><p>隐式链接名称快捷方式允许您省略链接的名称，在这种情况下，链接文本本身将用作名称。只需使用一组空的方括号，例如，将“Google”一词链接到google.com网站，您只需写下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[Google]</span><span class="hljs-selector-attr">[]</span><br>然后定义链接：<br><br><span class="hljs-selector-attr">[Google]</span>: <span class="hljs-selector-tag">http</span>:<span class="hljs-comment">//google.com/</span><br></code></pre></td></tr></table></figure><p>在typora中单击链接将其展开以进行编辑，command + 单击将在 Web 浏览器中打开超链接。+</p><p>比如：</p><p><a href="https://github.com/manxingyu?tab=repositories">我的github库</a></p><p>Typora允许您将 URL 作为链接插入，用 <code>&lt;</code>括号括起来<code>&gt;</code>。</p><p><code>&lt;i@typora.io&gt;</code> 成为 <a href="mailto:i@typora.io">i@typora.io</a>.</p><p>Typora也将自动链接标准URL。例如：&lt;<a href="https://github.com/manxingyu?tab=repositories">Your Repositories (github.com)</a>&gt;</p><h4 id="4-9-图片"><a href="#4-9-图片" class="headerlink" title="4.9 图片"></a>4.9 图片</h4><p>图像与链接类似， 但在链接语法之前需要添加额外的 <code>!</code> 字符。 图像语法如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">!<span class="hljs-selector-attr">[替代文字]</span>(/path/<span class="hljs-selector-tag">to</span>/<span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.jpg</span>)<br><br>!<span class="hljs-selector-attr">[替代文字]</span>(/path/<span class="hljs-selector-tag">to</span>/<span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.jpg</span> &quot;可选标题&quot;)<br></code></pre></td></tr></table></figure><p>您可以使用拖放操作从图像文件或浏览器来插入图像。并通过单击图像修改 markdown 源代码。如果图像在拖放时与当前编辑文档位于同一目录或子目录中，则将使用相对路径.</p><h4 id="4-10-符号’……’"><a href="#4-10-符号’……’" class="headerlink" title="4.10 符号’……’"></a>4.10 符号’……’</h4><p>起到标记作用。如：</p><blockquote><p>`ctrl+a`</p></blockquote><p>效果：</p><blockquote><p><code>ctrl+a</code>    </p></blockquote><h4 id="4-11脚注"><a href="#4-11脚注" class="headerlink" title="4.11脚注"></a>4.11脚注</h4><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">您可以像这样创建脚注[^footnote].<br><br>[^footnote]: <span class="hljs-symbol">Here</span> is the *text* of the **footnote**.<br></code></pre></td></tr></table></figure><p>将产生：</p><p>您可以像这样创建脚注:</p><p>这是<a href="%E8%84%9A%E6%B3%A8%E7%BC%96%E8%BE%91%E6%96%87%E6%9C%AC">^脚注</a> </p><p>鼠标移动到‘脚注’上标中查看脚注的内容。</p><h4 id="4-12删除线"><a href="#4-12删除线" class="headerlink" title="4.12删除线"></a>4.12删除线</h4><p>GFM通过添加语法来创建删除线文本，标准的Markdown中缺少该文本。</p><p><code>~~错误的文字。~~</code> 变成 <del>错误的文字。</del></p><h4 id="4-13下划线"><a href="#4-13下划线" class="headerlink" title="4.13下划线"></a>4.13下划线</h4><p>下划线由原始HTML提供支持。</p><p><code>&lt;u&gt;下划线&lt;/u&gt;</code> 变成 下划线</p><h4 id="4-14表情符号-smile"><a href="#4-14表情符号-smile" class="headerlink" title="4.14表情符号 :smile:"></a>4.14表情符号 :smile:</h4><p>输入表情符号的语法是 <code>:smile:</code></p><p>用户可以通过 <code>ESC</code> 按键触发表情符号的自动完成建议，或者在偏好设置面板里启用后自动触发表情符号。此外，还支持直接从 <code>Edit</code> -&gt; <code>Emoji &amp; Symbols</code> 菜单栏输入UTF8表情符号字符。</p><h4 id="4-15任务列表"><a href="#4-15任务列表" class="headerlink" title="4.15任务列表"></a>4.15任务列表</h4><p>任务列表是标记为[ ]或[x]（未完成或完成）的项目的列表。例如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">- <span class="hljs-selector-attr">[ ]</span> 这是一个任务列表项<br>- <span class="hljs-selector-attr">[ ]</span> 需要在前面使用列表的语法<br>- <span class="hljs-selector-attr">[ ]</span> <span class="hljs-attribute">normal</span> **formatting**, @mentions, <span class="hljs-number">#1234</span> refs<br>- <span class="hljs-selector-attr">[ ]</span> 未完成<br>- <span class="hljs-selector-attr">[x]</span> 完成<br></code></pre></td></tr></table></figure><p>您可以通过单击项目前面的复选框来更改完成&#x2F;未完成状态。</p><p>‘ - [ ] 任务 ‘</p><ul><li><input disabled="" type="checkbox"> 任务</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Markdowm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/08/14/hello-world/"/>
    <url>/2022/08/14/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><figcaption><span>#可以复制的意思 下面是代码块</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New blog&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
