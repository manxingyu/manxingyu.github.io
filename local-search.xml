<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>opencv库函数</title>
    <link href="/2022/08/15/page/"/>
    <url>/2022/08/15/page/</url>
    
    <content type="html"><![CDATA[<h1 id="图像显示、处理："><a href="#图像显示、处理：" class="headerlink" title="图像显示、处理："></a>图像显示、处理：</h1><h2 id="cv2-imread"><a href="#cv2-imread" class="headerlink" title="cv2.imread"></a>cv2.imread</h2><p>img &#x3D;cv2.imread(“address”,flags)</p><p>flags：标志位，{cv2.IMREAD_COLOR，cv2.IMREAD_GRAYSCALE，cv2.IMREAD_UNCHANGED}</p><p>cv2.IMREAD_COLOR：默认参数，读入一副彩色图片，忽略alpha通道，可用1作为实参替代</p><p>cv2.IMREAD_GRAYSCALE：读入灰度图片，可用0作为实参替代</p><p>cv2.IMREAD_UNCHANGED：顾名思义，读入完整图片，包括alpha通道，可用-1作为实参替代</p><p>PS：alpha通道，又称A通道，是一个8位的灰度通道，该通道用256级灰度来记录图像中的透明度复信息，定义透明、不透明和半透明区域，其中黑表示全透明，白表示不透明，灰表示半透明</p><h2 id="cv2-resize"><a href="#cv2-resize" class="headerlink" title="cv2.resize"></a>cv2.resize</h2><p>cv2.resize (图像,dsize&#x3D;None,fx&#x3D;2,fy&#x3D;2,interpolation)</p><p> cv2.resize（）函数中，主要用到的形参包括</p><p>输入Mat数据，</p><p>dsize：代表期望的输出图像大小尺寸</p><p>fx：代表水平方向上（图像宽度）的缩放系数，</p><p>fy：代表竖直方向上（图像高度）的缩放系数，另外，如果dsize被设置为0（None），则按fx与fy与原始图像大小相乘得到输出图像尺寸大小。</p><p>interpolation：插值方式，默认选择线性插值，越复杂的插值方式带来的改变和差异越大。</p><h2 id="cv2-imshow"><a href="#cv2-imshow" class="headerlink" title="cv2.imshow"></a>cv2.imshow</h2><p>原型：imshow(winname,mat)<br> 作用：创建一个图像窗口<br> 参数：winname，窗口名称。mat，图像矩阵。</p><h2 id="cv2-waitKey"><a href="#cv2-waitKey" class="headerlink" title="cv2.waitKey"></a>cv2.waitKey</h2><p>原型：waitKey(delay&#x3D;None) 为0 时则是等待按键的意思<br> 作用；接受一个按键事件并返回按键的ASCII码。<br> 参数：delay为按下后返回的延迟时间。</p><h2 id="cv2-destroyWindow"><a href="#cv2-destroyWindow" class="headerlink" title="cv2.destroyWindow"></a>cv2.destroyWindow</h2><p>原型： destroyWindow(winname)<br> 作用：关闭一个由imshow产生的图像窗口<br> 参数：winname，关闭的窗口名字</p><h2 id="cv2-cvtColor"><a href="#cv2-cvtColor" class="headerlink" title="cv2.cvtColor"></a>cv2.cvtColor</h2><p>原型：cvtColor(src,code,dst&#x3D;None,dstCn&#x3D;None)<br> 作用：将一幅图像从一个色彩空间转换到另一个色彩空间<br> 参数：code，转换的色彩空间</p><h2 id="cv2-threshold"><a href="#cv2-threshold" class="headerlink" title="cv2.threshold"></a>cv2.threshold</h2><p>原型：threshold(src,thresh,maxval,type,dst&#x3D;None)<br> 作用：将图像的每个像素点进行二值化<br> 参数：thresh，阈值值。maxval，二值化的最大取值。type，二值化类型，一般设为0</p><h2 id="cv2-selectROI"><a href="#cv2-selectROI" class="headerlink" title="cv2.selectROI"></a>cv2.selectROI</h2><p>rect &#x3D; cv2.selectROI(“image”, img, showCrosshair, fromCenter)</p><p>“image” : winName 窗口名称</p><p>img : 目标想要裁剪的图像</p><p>showCrosshair : 是否显示网格</p><p>True 显示网格</p><p>False 只有矩形</p><p>fromCenter:</p><p>True 第一次选中的点为矩形的中心.</p><p>False 第一次选中的点为矩形的左上角.</p><p>返回的是一个tuple值, 代表矩形区域. 分别代表矩形左上角坐标 (x, y) 与矩形宽度<code>w</code>跟高度<code>h</code></p><p>(x, y, w, h) &#x3D; rect</p><p>用法：</p><p>rect&#x3D;cv2.selectROI(“22”,img,False)<br> (x, y, w, h) &#x3D; rect<br> im &#x3D; img[y : y+h, x:x+w]</p><h2 id="cv2-Shape"><a href="#cv2-Shape" class="headerlink" title="cv2. Shape"></a>cv2. Shape</h2><p>返回值：</p><p>shape[0] &#x3D;图像的高<br> shape[1] &#x3D;图像的宽<br> shape[2] &#x3D; 图像的图像<a href="https://so.csdn.net/so/search?q=%E9%80%9A%E9%81%93&spm=1001.2101.3001.7020">通道</a>数量</p><h2 id="cv2-split（）"><a href="#cv2-split（）" class="headerlink" title="cv2.split（）"></a>cv2.split（）</h2><p>通道拆分</p><p>返回值：</p><p>b,g,r&#x3D; cv2.split（图像）</p><p>cv2.merge（[b, g, r]）</p><p>cv2.merge(mv[, dst]) -&gt; retval # BGR 通道合并</p><p>参数说明：</p><p>mv：要合并的单通道</p><p>dst：通道合并的图像，nparray 多维数组</p><p>Numpy库加法的运算方法为：</p><p>目标图像 &#x3D; 图像1 + 图像2，运算结果进行取模运算。有以下两种情况：</p><p>（1）当像素值 &lt;&#x3D; 255时，结果为“图像1+图像2”，例如：120+48&#x3D;168</p><p>（2）当像素值 &gt; 255时，结果为对255取模的结果，例如：(255+64) % 255&#x3D;64</p><h2 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h2><p>OpenCV库实现图像加法运算，方法如下：</p><p>目标图像 &#x3D; cv2.add(图像1, 图像2)  。 此时结果是饱和运算，有以下两种情况：</p><p>（1）当像素值 &lt;&#x3D; 255时，结果为“图像1+图像2”，例如：120+48&#x3D;168</p><p>（2）当像素值 &gt; 255时，结果为255，例如：(255+64) &#x3D; 255  <strong>注意与<strong><strong>numpy</strong></strong>加法运算的区别！！！</strong></p><h2 id="addWeighted"><a href="#addWeighted" class="headerlink" title="addWeighted()"></a>addWeighted()</h2><p>图像融合：目标图像 &#x3D; 图像1 系数1 + 图像2  系数2 + 亮度调节量</p><p>dst &#x3D; cv2.addWeighter(scr1, alpha, src2, beta, gamma)</p><p>dst &#x3D; src1 alpha + src2  beta + gamma</p><p>其中，参数gamma不能省略</p><h2 id="cv2-copyMakeBorder"><a href="#cv2-copyMakeBorder" class="headerlink" title="cv2.copyMakeBorder()"></a>cv2.copyMakeBorder()</h2><p>为图像扩边（填充）<br> 想为图像周围建一个边可以使用cv2.copyMakeBorder()函数。这经常在卷积运算或0填充时被用到。</p><h2 id="cv2-copyMakeBorder-src-top-bottom-left-right-borderType-value"><a href="#cv2-copyMakeBorder-src-top-bottom-left-right-borderType-value" class="headerlink" title="cv2.copyMakeBorder(src,top,bottom,left,right,borderType,value)"></a>cv2.copyMakeBorder(src,top,bottom,left,right,borderType,value)</h2><p>具体参数如下：<br> src输入图像<br> top,bottom,left,right对应边界的像素数目<br> borderType要添加哪种类型的边界：<br> cv2.BORDER_CONSTANT添加有颜色的常数值边界，还需要下一个参数（value）<br> cv2.BORDER_REFLIECT边界元素的镜像。例如：fedcba | abcdefgh | hgfedcb<br> cv2.BORDER_101或者cv2.BORDER_DEFAULT跟上面一样，但稍作改动，例如：gfedcb | abcdefgh | gfedcba<br> cv2.BORDER_REPLICATE复后一个元素。例如: aaaaaa| abcdefgh|hhhhhhh<br> cv2.BORDER_WRAP 不知怎么了, 就像样: cdefgh| abcdefgh|abcdefg<br> value:边界颜色</p><h2 id="cv2-inRange（）"><a href="#cv2-inRange（）" class="headerlink" title="cv2.inRange（）"></a>cv2.inRange（）</h2><p>mask &#x3D; cv2.inRange(hsv, lower, upper) </p><p>函数很简单，参数有三个</p><p>第一个参数：hsv指的是原图</p><p>第二个参数：lower_指的是图像中低于这个lower的值，图像值变为0</p><p>第三个参数：upper指的是图像中高于这个upper的值，图像值变为0</p><p>而在lower～upper之间的值变成255</p><p>可以用阈值的范围来选择颜色</p><p><img src="/img/page,hsv.jpg" alt="img"></p><h2 id="cv2-bitwise-and-src1src2-mask-x3D-X"><a href="#cv2-bitwise-and-src1src2-mask-x3D-X" class="headerlink" title="cv2.bitwise_and(src1src2,mask&#x3D;X)"></a>cv2.bitwise_and(src1src2,mask&#x3D;X)</h2><p> src1表示第一个array或scalar类型的输入值。</p><p> src2表示第二个array或scalar类型的输入值。</p><p>X表示可选操作掩码，8位单通道array，选择图像。</p><p>cv2.bitwise_and()是对二进制数据进行“与”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“与”操作，1&amp;1&#x3D;1，1&amp;0&#x3D;0，0&amp;1&#x3D;0，0&amp;0&#x3D;0</p><h2 id="空间域滤波"><a href="#空间域滤波" class="headerlink" title="空间域滤波"></a>空间域滤波</h2><h2 id="cv2-blur-原始图像-核大小"><a href="#cv2-blur-原始图像-核大小" class="headerlink" title="cv2.blur(原始图像,核大小)"></a>cv2.blur(原始图像,核大小)</h2><p>均值滤波</p><p>指任意一点的像素值，都是周围 NxM个像素值的均值</p><p>注：</p><p>1）随着核大小逐渐变大，会让图像变得更加模糊；</p><p>2）如果设置为核大小为（1，1），则结果就是原始图像。</p><h2 id="cv2-medianBlur-src-ksize"><a href="#cv2-medianBlur-src-ksize" class="headerlink" title="cv2.medianBlur(src, ksize)"></a><strong>cv2.medianBlur(src, ksize)</strong></h2><p>这里的核大小ksize必须是奇数</p><p>将该点周围的像素点包括本身，按次序排列，取中位数作为点的像素值</p><p><strong>注：</strong></p><p>1）随着核大小逐渐变大，会让图像变得更加模糊；</p><p>2）核必须是大于1的<strong>奇数</strong>，如3、5、7等；</p><p>3）在代码 <strong>dst &#x3D; cv2.medianBlur(src, ksize)</strong> 中 填写核大小时，只需填写一个数即可，如3、5、7等，对比均值滤波函数用法。</p><h2 id="cv2-GaussianBlur-src-ksize-sigmaX"><a href="#cv2-GaussianBlur-src-ksize-sigmaX" class="headerlink" title="cv2.GaussianBlur(src, ksize, sigmaX)"></a><strong>cv2.GaussianBlur(src, ksize, sigmaX)</strong></h2><p>dst &#x3D; cv2.GaussianBlur(src, ksize, sigmaX, sigmaY, borderType) </p><p>——src输入图像。</p><p>——dst输出图像的大小和类型与src相同。</p><p>——ksize高斯内核大小。 ksize.width和ksize.height可以不同，但它们都必须为正数和奇数，也可以为零，然后根据sigmaX和sigmaY计算得出。</p><p>——sigmaX X方向上的高斯核标准偏差。</p><p>——sigmaY Y方向上的高斯核标准差；如果sigmaY为零，则将其设置为等于sigmaX；如果两个sigmas为零，则分别从ksize.width和ksize.height计算得出；为了完全控制结果，而不管将来可能对所有这些语义进行的修改，建议指定所有ksize，sigmaX和sigmaY。</p><h2 id="形态学处理"><a href="#形态学处理" class="headerlink" title="形态学处理"></a>形态学处理</h2><p><strong>腐蚀</strong>：<strong>cv2.<strong><strong>erode</strong></strong>(src, kernel, iterations)   #iterations****表示腐蚀几次</strong></p><p><strong>膨胀：****cv2.<strong><strong>dilate</strong></strong>(src, kernel, iterations)</strong></p><p><strong>开运算：****cv2.<strong><strong>morphologyEx</strong></strong>(src, cv2.<strong><strong>MORPH_OPEN</strong></strong>, kernel)</strong></p><p>*<em>闭运算：</em>***cv2.****morphologyEx(**<strong>src, cv2.<strong><strong>MORPH_CLOSE</strong></strong>, kernel)</strong></p><p># 设置卷积核<br> kernel &#x3D; np.ones((3, 3), np.uint8)<br> ‘’’形态学6种操作’’’<br> # 腐蚀<br> fushi &#x3D; cv2.erode(src, kernel)<br> # 膨胀<br> pengzhang &#x3D; cv2.dilate(src, kernel)<br> # 开运算<br> kai &#x3D; cv2.morphologyEx(src, cv2.MORPH_OPEN, kernel)<br> # 闭运算<br> bi &#x3D; cv2.morphologyEx(src, cv2.MORPH_CLOSE, kernel)<br> # 顶帽运算<br> tophat &#x3D; cv2.morphologyEx(src, cv2.MORPH_TOPHAT, kernel)<br> # 黑帽运算<br> blackhat &#x3D; cv2.morphologyEx(src, cv2.MORPH_BLACKHAT, kernel)</p><p><a href="https://docs.opencv.org/4.x/d9/d61/tutorial_py_morphological_ops.html">OpenCV：形态学转化</a></p><p><img src="/img/page,1.jpg" alt="img"></p><h2 id="sobel算子"><a href="#sobel算子" class="headerlink" title="sobel算子"></a>sobel算子</h2><p># ddepth：cv2.CV_， 结果图像的位深</p><p># dx：对 x 方向求偏导</p><p># dy：对 y 方向求偏导</p><p># ksize：卷积核大小</p><p>cv2.Sobel(src, ddepth, dx:bool, dy:bool[, dst[, ksize:int[, scale[, delta[, borderType]]]]]) -&gt; dst</p><p>cv2.convertScaleAbs(src[, dst[, alpha[, beta]]]) -&gt; dst# src中的数据取绝对值</p><p>Sobel计算，会导致像素值为负，因此输出图像的位深ddepth应当使用「有符号类型」，例如cv2.CV_16S、cv2.CV_32F等</p><p>颜色通道数值不存在负数，所以还需要对计算结果取绝对值convertScaleAbs</p><p>对于横向、竖向的边界提取要分两次进行，一起提取效果很差</p><h2 id="Scharr算子（sobel算子改进版）"><a href="#Scharr算子（sobel算子改进版）" class="headerlink" title="Scharr算子（sobel算子改进版）"></a>Scharr算子（sobel算子改进版）</h2><p>cv2.Scharr(src, ddepth, dx, dy[, dst[, scale[, delta[, borderType]]]]) -&gt; dst</p><p>相比sobel算子卷积核ksize大小固定为<code>3x3</code></p><p>src：原始图像</p><p>ddepth：处理结果图像深度</p><p>dx：x轴方向</p><p>dy：y轴方向</p><h2 id="Laplacian算子"><a href="#Laplacian算子" class="headerlink" title="Laplacian算子"></a>Laplacian算子</h2><p><strong>dst &#x3D; cv2.Laplacian(src, ddepth)</strong></p><p> 注意：通常情况下，可以将图像深度ddepth的值设置为-1，让处理结果与原始图像保持一致</p><h2 id="cv2-Canny（）"><a href="#cv2-Canny（）" class="headerlink" title="cv2.Canny（）"></a>cv2.Canny（）</h2><p><strong>edges &#x3D;  cv2.Canny(image, threshold1, threshold2)</strong></p><p>image： 原始图像</p><p>threshold1： 阈值1 minVal</p><p>threshold2： 阈值2 maxVal</p><p> threshold值越小，细节越丰富</p><h2 id="cv2-pyrDown-img"><a href="#cv2-pyrDown-img" class="headerlink" title="cv2. pyrDown(img)"></a>cv2. pyrDown(img)</h2><p>将img图像缩小2倍</p><h2 id="cv2-pyrUp-img"><a href="#cv2-pyrUp-img" class="headerlink" title="cv2. pyrUp(img)"></a>cv2. pyrUp(img)</h2><p>将img图像放大两倍 </p><h2 id="cv2-findContours-image-mode-method"><a href="#cv2-findContours-image-mode-method" class="headerlink" title="cv2.findContours(image, mode, method)"></a>cv2.findContours(image, mode, method)</h2><p>mode: 轮廓检索模式</p><p>RETR_EXTERNAL:只检索最外面的轮廓；</p><p>RETR_LIST:检索所有的轮廓，并将其保存到一条链表当中；</p><p>RETR_CCOMP:检索所有的轮廓，并将他们组织为两层：顶层是各部分的外部边界，第二层是空洞的边界：</p><p><strong>RETR_TREE</strong>: 检索所有的轮廓，并重构嵌套轮廓的整个层次； <strong>最常用。</strong></p><p>method: 重新绘制轮廓的算法</p><p>CHAIN_APPROX_NONE:以Freeman链码的方式输出轮廓，轮廓信息完整保留</p><p>CHAIN_APPROX_SIMPLE:压缩水平的、垂直的和斜的部分，只保留顶点</p><p><strong>函数返回值：contours, hierarchy</strong></p><p>contours：从图像中查找出来的轮廓数组</p><p>hierarchy：轮廓层级</p><h2 id="cv2-drawContours（）"><a href="#cv2-drawContours（）" class="headerlink" title="cv2.drawContours（）"></a>cv2.drawContours（）</h2><p>canvas：轮廓要绘制在哪张背景图上，直接覆盖原图</p><p>contours：findContours 找到的轮廓信息</p><p>contourIdx：轮廓数组contours的索引值，-1 为全部</p><p>color：轮廓颜色</p><p>thickness：轮廓厚度</p><p>cv2.drawContours(canva:image, contours, contourIdx, color， thickness) -&gt; image</p><h1 id="时间的测量和计时："><a href="#时间的测量和计时：" class="headerlink" title="时间的测量和计时："></a>时间的测量和计时：</h1><p><a href="https://docs.opencv.org/4.0.0/db/de0/group__core__utils.html#gae73f58000611a1af25dd36d496bf4487"><strong>cv.getTickCount</strong></a>函数返回参考事件（如机器开启时刻）到调用此函数的时钟周期数。因此，如果在函数执行之前和之后调用它，则会获得用于执行函数的时钟周期数。</p><p><a href="https://docs.opencv.org/4.0.0/db/de0/group__core__utils.html#ga705441a9ef01f47acdc55d87fbe5090c"><strong>cv.getTickFrequency</strong></a>函数返回时钟周期的频率，或每秒钟的时钟周期数</p><p><code>e1 </code>&#x3D;<code> cv</code>.<code>getTickCount</code>()&#96;&#96;</p><p>#你的执行的代码&#96;&#96;</p><p><code>e2 </code>&#x3D;<code> cv</code>.<code>getTickCount</code>()&#96;&#96;</p><p><code>time </code>&#x3D;<code> </code>(<code>e2 </code>-<code> e1</code>)&#x2F;<code>cv</code>.<code>getTickFrequency</code>()</p>]]></content>
    
    
    
    <tags>
      
      <tag>opencv</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my blog</title>
    <link href="/2022/08/14/test/"/>
    <url>/2022/08/14/test/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/08/14/hello-world/"/>
    <url>/2022/08/14/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><figcaption><span>#可以复制的意思 下面是代码块</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New blog&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
